package com.XX_DOMAIN_NAME.XX_APP_NAME.contact.personalinfo;

import java.time.LocalDate;
import java.util.UUID;

import com.XX_DOMAIN_NAME.XX_APP_NAME.contact.personalinfo.dto.PersonalInfoRequestDto;
import com.XX_DOMAIN_NAME.XX_APP_NAME.contact.personalinfo.dto.PersonalInfoResponseDto;
import com.XX_DOMAIN_NAME.XX_APP_NAME.location.address.Address;
import com.XX_DOMAIN_NAME.XX_APP_NAME.utils.validator.MinYearsAgo;

import jakarta.persistence.Column;
import jakarta.persistence.Embedded;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Past;
import jakarta.validation.constraints.Pattern;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Saving common personal info (things like fname, lname, phone_no,...) in one entity along with
 * embedded Address. There are updatable fields like 'email' and 'phone_no' and there are non updatable
 * ones like 'fname' or 'lname'. About 'birthDate', I leave it out to user, they can change it anytime 
 * they like.
 * 
 * If you try to change fname or lname, you'll get a "nothing_to_change" 400 error and you're gonna have 
 * to contact support for that purpose. 
 * 
 * Change this behaviour by changing the "update" method and the @Column annotation for unchangable fields. 
 * 
 * */
@Entity @Table(name="personal_info")
@Data @NoArgsConstructor @AllArgsConstructor @Builder
public class PersonalInfo {
	
	// XXX TODO write in NOKAT: if you choose the wrong GenerationType, 
	// your table will fucking drop silently without a warning XXX
	@Column(updatable = false)
	@Id @GeneratedValue(strategy = GenerationType.AUTO)
	private UUID id; // not necessary to save as UUID's as of now

	// XXX if it's a Contact's personal_info, then the email can be false. otherwise
	// if it's a user's pi, it must be verified (in services!)
	@Column(nullable=false,unique = false)
	@Pattern(
		regexp="^^[A-Za-z][\\w\\-_\\.+]{3,64}@([\\w][\\w\\-_\\.]{3,32}[\\w]\\.[A-Za-z]{2,16}|localhost)$",
		message="err.personal_info.email.format"
	)
	@NotBlank(message="err.personal_info.email.blank")
	private String email;
	
	@Column(nullable=true)
	@Pattern(
		regexp="^(\\+|00|0)\\d{7,15}$", 
		message="err.personal_info.phone.format"
	)
	@NotBlank(message="err.personal_info.phone_no.blank")
	private String phoneNo;
	
	@Column(nullable=false,updatable = false)
	@Pattern(regexp = "^[A-Za-z ]{3,32}$",message="err.personal_info.name.format")
	@NotBlank(message="err.personal_info.lname.blank")
	private String lname;
	
	@Column(nullable=false,updatable = false)
	@Pattern(regexp = "^[A-Za-z ]{3,32}$",message="err.personal_info.name.format")
	@NotBlank(message="err.personal_info.fname.blank")
	private String fname;
	
	@Embedded
	@Valid
	private Address address;
	
	@Column(nullable=true)
	@Past(message = "err.personal_info.birth_date.present_or_future")
	@NotNull(message="err.personal_info.birth_date.null")
	@MinYearsAgo(value= 18l,message="err.personal_info.birth_date.must_be_at_least_18")
	private LocalDate birthDate;
	
	@Column(nullable=true)
	private String picture; // base64
	
	public PersonalInfoResponseDto toResponseDto() {
		return toResponseDto(true);
	}
	
	/**
	 * Mutates then current object with new object's fields if they're not null. This method is
	 * suitable after you retrieve an object from database and wanna update it's fields then 
	 * persist the object and overwriting the old database row.
	 * 
	 * The fields 'fname' and 'lname' are unupdatable in db but still deliberately left out in 
	 * this method to avoid extra db calls. 
	 * 
	 * @param PersonalInfo
	 * @return boolean if any change has occured, so you know whether to put back in db.
	 * */
	public boolean update(PersonalInfo src) {
		boolean hasChanged=false;
		if(src.getEmail()!=null && !src.getEmail().equals(email)) {
			hasChanged=true;
			this.email=src.getEmail();
		}
		if(src.getPhoneNo()!=null && !src.getPhoneNo().equals(phoneNo)) {
			hasChanged=true;
			this.phoneNo=src.getPhoneNo();
		}
		if(src.getAddress()!=null && !src.getAddress().equals(address)) {
			hasChanged=true;
			if(this.address==null) this.address=src.getAddress();
			else this.address.update(src.getAddress());
		}
		if(src.getBirthDate()!=null && !src.getBirthDate().equals(birthDate)) {
			hasChanged=true;
			this.birthDate=src.getBirthDate();
		}
		return hasChanged;
	}
	
	@Override
	public boolean equals(Object o){
		// generated by gen_update_method in side_progs/
		if(!(o instanceof PersonalInfo)) return false;
		PersonalInfo target=(PersonalInfo) o;
		return 	( (email==null && target.getEmail()==null ) || ( email!=null && email.equals(target.getEmail())) )
		&&	( (fname==null && target.getFname()==null ) || ( fname!=null && fname.equals(target.getFname())) )
		&&	( (lname==null && target.getLname()==null ) || ( lname!=null && lname.equals(target.getLname())) )
		&&	( (phoneNo==null && target.getPhoneNo()==null ) || ( phoneNo!=null && phoneNo.equals(target.getPhoneNo())) )
		&&	( (address==null && target.getAddress()==null ) || ( address!=null && address.equals(target.getAddress())) )
		&&	( (birthDate==null && target.getBirthDate()==null ) || ( birthDate!=null && birthDate.equals(target.getBirthDate())) )
		&&	true;
	}
	
	@Override
	public int hashCode() {return id.hashCode();}
	
	/**
	 * All integrity checks are done at service level, so this method does not care
	 * if the provided dto has all it's fields initialized or not.
	 * You can if separate update and create dto and apply different logic to them if
	 * you want,but since this is a starter pack,I just let database decide about integrity.
	 * */
	public static PersonalInfo ofDto(PersonalInfoRequestDto dto) {
		return PersonalInfo.builder()
				.address(dto.getAddress()!=null?Address.ofDto(dto.getAddress()):new Address())
				.birthDate(dto.getBirthDate())
				.email(dto.getEmail())
				.fname(dto.getFname())
				.id(dto.getId())
				.lname(dto.getLname())
				.phoneNo(dto.getPhoneNo())
				.picture(dto.getPicture())
				.build();
	}
	
	/**
	 * Since authorization checks are at service level, passing an 'authorized' boolean
	 * is ok by now, but if you are worried edit this method and add a PostAuthroize or
	 * whatever.
	 * @param boolean whether the receiving user is authorized to see this.
	 * */
	public PersonalInfoResponseDto toResponseDto(boolean authroized) {
		return PersonalInfoResponseDto.builder()
				.address(authroized?address.toDot():null)
				.birthDate(authroized?birthDate:null)
				.email(authroized?email:null)
				.fname(fname)
				.lname(lname)
				.phoneNo(authroized?phoneNo:null)
				.picture(picture)
				.id(id)
				.build();
	}
	
}
