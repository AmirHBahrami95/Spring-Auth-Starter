package com.XX_DOMAIN_NAME.XX_APP_NAME.location.address;

import com.XX_DOMAIN_NAME.XX_APP_NAME.location.address.dto.AddressRequestDto;
import com.XX_DOMAIN_NAME.XX_APP_NAME.location.address.dto.AddressResponseDto;
import com.XX_DOMAIN_NAME.XX_APP_NAME.location.country.Country;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * General class who can act as any sort of Address, including residence, company, shipping, etc.
 * */
@Embeddable
@Data @NoArgsConstructor @AllArgsConstructor @Builder 
public class Address {
	
	@ManyToOne(cascade = CascadeType.DETACH)
	@JoinColumn(nullable = false,name= "country_iso2")
	@NotNull(message="err.address.country.null")
	private Country country;
	
	@Column(nullable = false)
	@Pattern(regexp = "^[A-Za-z][A-Za-z\\s\\-_]{3,32}$" , message="err.address.state.wrong_format")
	@NotBlank(message="err.address.state.blank")
	private String state;
	
	@Column(nullable = false)
	@Pattern(regexp = "^[A-Za-z][A-Za-z\\s\\-_]{3,32}$", message="err.address.city.wrong_format")
	@NotBlank(message="err.address.city.blank")
	private String city;
	
	@Column(nullable = false)
	@Pattern(regexp = "^[A-Za-z][\\w\\d\\-,_\\W]{3,256}$", message="err.address.local.wrong_format")
	@NotBlank(message="err.address.local.blank")
	private String local; // anything smaller than street, including apartment and room numbers
	
	@Override
	public int hashCode() {
		return country.hashCode()+city.hashCode()+state.hashCode()+local.hashCode();
	}
	
	public boolean update(Address src) {
		boolean hasChanged=false;
		if(src.getCountry()!=null && !src.getCountry().equals(country)) {
			hasChanged=true;
			
			// if the src's country's fields are set to null, this object will
			// also have fields overwritten by null.
			if(this.country==null) country.update(src.getCountry());
			else this.country=src.getCountry();
		}
		if(src.getCity()!=null && !src.getCity().equals(city)) {
			hasChanged=true;
			this.city=src.getCity();
		}
		if(src.getState()!=null && !src.getState().equals(state)) {
			hasChanged=true;
			this.state=src.getState();
		}
		if(src.getLocal()!=null && !src.getLocal().equals(local)) {
			hasChanged=true;
			this.local=src.getLocal();
		}
		return hasChanged;
	}
	
	@Override
	public boolean equals(Object o){
		// generated by gen_update_method in side_progs/
		if(!(o instanceof Address)) return false;
		Address target=(Address) o;
		return 	( (country==null && target.getCountry()==null ) || ( country!=null && country.equals(target.getCountry())) )
		&&	( (city==null && target.getCity()==null ) || ( city!=null && city.equals(target.getCity())) )
		&&	( (state==null && target.getState()==null ) || ( state!=null && state.equals(target.getState())) )
		&&	( (local==null && target.getLocal()==null ) || ( local!=null && local.equals(target.getLocal())) )
		&&	true;
	}
	
	public static Address ofDto(AddressRequestDto dto) {
		return Address.builder()
				.country(Country.builder().iso2(dto.getCountryIso2()!=null?dto.getCountryIso2().toLowerCase():null).build())
				.state(dto.getState())
				.city(dto.getCity())
				.local(dto.getLocal())
				.build();
	}
	
	public AddressResponseDto toDot() {
		return AddressResponseDto.builder()
				.countryIso2(country.getIso2())
				.state(state)
				.city(city)
				.local(local)
				.build();
	}

}
