package com.XX_DOMAIN_NAME.XX_APP_NAME.location.country;

import com.XX_DOMAIN_NAME.XX_APP_NAME.location.country.dto.CountryResponseDto;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Data @NoArgsConstructor @AllArgsConstructor @Builder 
public class Country {
	
	@Id
	private String iso2;
	
	@Column(nullable = false)
	private String name;
	
	@Column(nullable=false)
	private String dialCode;
	
	/**
	 * TODO add in NOKAT
	 * Since Countries are read only and they are almost static resources you should NOT
	 * update "name" or "dialCode" in other entities' update methods. If you do so that'll
	 * be an attempt at updating the id and throw an exception.
	 * 
	 * Explained:
	 * Bc in order to update a PersonalInfo, you first fetch the existing PersonalInfo from
	 * db and by doing that, you have your previous fields initialized. if your dto has a 
	 * different countryIso2 than what you fetched from the db, it's considered an Id update
	 * and that's not healthy and the db won't allow that. so, just keep this update method
	 * as is, and stop giving a fuck about it, instead just use it properly (in recursive update
	 * calls on db context objects).
	 * 
	 * ==========
	 * 
	 * TODO in NOKAT:
	 * These update methods are NOT supposed to throw any exceptions, as returning false can
	 * be enough. this is limiting if you wanna tell user he cannot for instance change his fname
	 * but that's ok, after attempting a few times they'll decide to contact support anyways.
	 * 
	 * u use update methods for 2 reasons: 1. integrity (not overwriting fetched db object's already
	 * initialized fields) 2. avoiding unnecessary db calls if no change has actually happened.
	 * for the second reason, you have to return a 'hasChanged' object form your update method
	 * and it has to propagate through upper update calls until it reaches the Service and at service
	 * level you'll decide whether to persist the object (if the calls end product has been true) or
	 * just send an exception with "nothing_changed" 400 error.
	 * 
	 * as a rule of thumb: update methods are supposed to only check and update updatable fields (obviously)
	 * and you should deliberately avoid doing any other stuff in these methods.
	 * 
	 *  =========
	 * 
	 * @param Country src
	 * @retun true if object was changed
	 * */
	public boolean update(Country src) {
		boolean hasChanged=false;
		if(src.getIso2()!=null && !src.getIso2().equals(iso2)) {
			hasChanged=true;
			this.iso2=src.getIso2();
		}
		return hasChanged;
	}
	
	/**
	 * Mainly is gonna be used inside other Entities' update() method, so it's viable if 
	 * you only check the ID field.
	 * */
	@Override
	public boolean equals(Object o){
		// generated by gen_update_method in side_progs/
		if(!(o instanceof Country)) return false;
		Country target=(Country) o;
		return 	( (iso2==null && target.getIso2()==null ) || ( iso2!=null && iso2.equals(target.getIso2())) )
		&&	true;
	}
	
	@Override
	public int hashCode() {
		return iso2.hashCode()+dialCode.hashCode()+name.hashCode();
	}
	
	public CountryResponseDto toDto() {
		return CountryResponseDto.builder()
			.iso2(iso2)
			.dialCode(dialCode)
			.name(name)
			.iconUrl("/static/images/"+iso2+".png")
			.build();
	}
}
